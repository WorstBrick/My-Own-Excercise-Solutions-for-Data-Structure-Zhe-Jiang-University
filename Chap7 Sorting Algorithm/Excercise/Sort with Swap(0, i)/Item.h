/*总思路:
(1)寻找0所在的位置(索引)记为i0;
(2)若i0==0,即此时0就在正确的位置上,那么继续往后扫描数组,一旦发现有A[Index]!=Index的,就swap(0,Index),并进入步骤(3);否则说明整个数组有序,结束过程
   若i0!=0,进入步骤(3)
(3)由于(2)中的操作,此时必有i0!=0,找到以i0为元素的地址j(即有A[j]==I0),并swap(0,i0);
(4)重复以上步骤
*/

/*如何快速找到元素k当前所在的数组下标Index?(既有A[Index]==k)
用一个大小为N的"地址数组"Address[N],其下标(0~N-1)表示元素0~N-1,Address[k]表示元素k当前在数组A[]中的地址,每当发生swap时,更新Address[]的内容
*/

typedef int * Address;
typedef int Position;
